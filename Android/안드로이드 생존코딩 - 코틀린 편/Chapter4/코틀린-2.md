# 4장 코틀린 - 2



###   4.9 null 가능성

\- 기본적으로 객체를 불변으로 보고 null값을 허용하지 않습니다.



#### **4.9.1 null 허용?**

\- 코틀린에서 모든 객체는 생성과 동시에 값을 대입하여 초기화해야 합니다.

\- 코틀린에서 null 값을 허용하려면 자료형의 오른쪽에 <span style="color:green">?</span> 기호를 붙여주면 됩니다.

```kotlin
val a : String ? = null // OK
```



#### **4.9.2 lateinit 키워드로 늦은 초기화**

\- 초기화를 나중에 할 경우가 있을 때는 <span style="color:green">lateinit</span> 키워드를 변수 선언 앞에 추가하면 됩니다.

```kotlin
lateinit var a : String 

a = "hello"
prinln(a)  
```

<span style="color:green"> # lateinit은 다음 조건에서만 사용할 수 있습니다.</span>

- var 변수에서만 사용합니다.
- null 값으로 초기화할 수 없습니다.
- 초기화 전에는 변수를 사용할 수 없습니다.
- Int, Long, Double, Float에서는 사용할 수 없습니다.



#### **4.9.3 lazy로 늦은 초기화**

\- <span style="color:green">lazy</span> 는 값을 변경할 수 없는 val에 사용할 수 있습니다. val 선언 뒤에 by lazy 블록에 필요한 코드를 작성합니다.

\- 마지막 줄에는 초기화할 값을 작성합니다.

```kotlin
val str : String by lazy {
  println("초기화")
  "hello"
}

println(str) // 초기화; hello
println(str) // hello
```

<span style="color:green"># lazy는 다음 조건에서만 사용할 수 있습니다.</span>

- val에서만 사용합니다.



#### **4.9.4 null값이 아님을 보증(!!)**

\- 변수 뒤에 !!을 추가하면 null값이 아님을 보증하게 됩니다.

```kotlin
val name: String? = "키다리"

val name2: String = name // 에러 - null값일 수도 있어서
val name3: String? = name // OK 

val name4: String = name!! // OK - null값이 아님을 보증함
```



#### **4.9.5 안전한 호출(?.)**

\- 메소드 호출 시 점 연산자 대신 <span style="color:green">?.</span> 연산자를 사용하면 null값이 아닌 경우에만 호출됩니다.

```kotlin
val str: String? = null

var upperCase = if (str != null) str else null // null 
upperCase = str?.toUpperCase // null 값 반환
```



#### **4.9.6 엘비스 연산자(?:)**

\- 안전한 호출 시 null값이 아닌 기본값을 반환하고 싶을 때는 엘비스 연산자를 함께 사용합니다.

```kotlin
val str: String? = null

var upperCase = if (str != null) str else null // null
upperCase = str?.toUpperCase ?: "초기화하시오" // 초기화하시오 반환
```



### **4.10 컬렉션**

\- 컬렉션은 개발에 유용한 자료구조를 말합니다.



#### **4.10.1 리스트**

\- 요소를 변경할 수 없는 읽기 전용 리스트는 <span style="color:green">listOf()</span> 메소드로 작성할 수 있습니다.

```kotlin
val foods: List<String> = listOf("라면", "명륜진사갈비", "밥")

// 형추론으로 자료형을 생략할 수 있습니다.
val foods = listOf("라면", "명륜진사갈비", "밥")
```

\- 요소를 변경하는 리스트를 작성할 때는 <span style="color:green">mutableListOf()</span> 메소드를 사용합니다.

```kotlin
val foods: mutableListOf("라면", "명륜진사갈비", "밥")

foods.add("초밥") 		// 초밥을 맨 뒤에 추가
foods.removeAt(0)		 // 맨 앞의 아이템 삭제
foods[1] = "부대찌개"	 // foods.set(1, "부대찌개") 1번째 아이템을 부대찌개로 변경

println(foods)  		 // [명륜진사갈비, 부대찌개, 초밥]
println(foods[0])	   // 갈비
```



#### **4.10.2 맵**

\- 맵은 키와 값의 쌍으로 이루어진 키가 중복될 수 없는 자료구조입니다.

\- mapOf() 메소드를 읽기 전용 맵을 만들 수 있고, <span style="color:green">mutableMapOf()</span> 메소드로 수정이 가능한 맵을 만들 수 있습니다.

```kotlin
// 읽기 전용 맵
val map = mapOf("a" to 1, "b" to 2) 

// 변경 가능 맵
val citiesMap = mutableMapOf("한국" to "서울",
                            "일본" to "동경",
                            "중국" to "북경")

// 요소에 덮어쓰기
citiesMap["한국"] = "서울특별시"
// 추가
citiesMap["미국"] = "워싱턴"
```

\- 맵 전체의 키와 값을 탐색할 때는 다음과 같이 간단히 탐색할 수 있습니다.

```kotlin
// 맵의 키와 값을 탐색
for ((k, v) in map) {
  println("$k -> $v")
}
```



#### **4.10.3 집합**

\- setOf() 메소드로 읽기 전용 집합을, <span style="color:green">mutableSetOf()</span> 메소드로 수정 가능한 집합을 생성합니다.

\- 집합은 중복되지 않는 요소들로 구성된 자료구조입니다.

```kotlin
// 읽기 전용 집합
val citySet = setOf("서울", "부산")

// 수정 가능한 집합
val citySet2 = mutableSetOf("서울", "수원")
citySet2.add("안양") 		// 서울, 수원, 안양
citySet2.remove("수원") // 서울, 안양

// 집합의 크기
println(citySet2.size) // 2
// 서울이 집합에 포함되어 있는지
println(citySet2.contains("서울")) //true
```



